##BACKEND

##models.py

from django.db import models
from django.contrib.auth.models import User
import json
from . import sudoku_logic

# Create your models here.
class Sudoku(models.Model):
    player = models.ForeignKey(User, on_delete=models.CASCADE, null=True, blank=True, related_name='api_sudoku_games')
    puzzle = models.TextField()
    current_state = models.TextField()
    solution = models.TextField(blank=True, null=True)
    difficulty = models.CharField(max_length=10)
    time = models.IntegerField(default=0)
    is_finished = models.BooleanField(default=False)
    win = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    @classmethod
    def create(self, *args, **kwargs):
        print(args)
        print(kwargs)
        userid = args[0]['userid']
        difficulty = args[0]['difficulty']
        user = User.objects.get(id=userid)
        print(user, difficulty, userid)
        puzzle_pair = sudoku_logic.generate_puzzle(difficulty)
        puzzle = puzzle_pair[0]
        solution = puzzle_pair[1]
        puzzle_list = puzzle.tolist()
        current_state = self.transform_current_state_to_dict(puzzle_list)
        if puzzle is not None:
            Sudoku.objects.create(
                difficulty=difficulty, 
                puzzle=puzzle_list, 
                solution=solution.tolist(),
                current_state=current_state, 
                player=user)
            game = Sudoku.objects.filter(puzzle=puzzle_list, player=user).latest('created_at')
            return game
        else:
            print('Failed to create game')
            return None
        
    def save(self, *args, **kwargs):
        # If puzzle or current_state is a Python list (or other structure), convert to JSON string before saving
        if isinstance(self.puzzle, list):
            self.puzzle = json.dumps(self.puzzle)
        if isinstance(self.current_state, list):
            self.current_state = json.dumps(self.current_state)
        if isinstance(self.solution, list):
            self.solution = json.dumps(self.solution)
        super().save(*args, **kwargs)

    def load_current_state(self):
        # Deserialize the current_state from JSON string back to Python object
        if isinstance(self.current_state, str):
            try:
                return json.loads(self.current_state)
            except json.JSONDecodeError:
                # Handle error or return a default value if JSON is corrupted
                return None
        return self.current_state  # or some default value if it's neither a string nor a list

    def __str__(self):
        return f'{self.difficulty} Sudoku on {self.created_at.strftime("%d-%b-%Y")}'

    
    @staticmethod
    def get_user_games(userid):
        try:
            user = User.objects.get(id=userid)
            return Sudoku.objects.filter(player=user).order_by('-created_at')
        except:
            return None
        
    @staticmethod
    def transform_puzzle(puzzle):
        transformed_puzzle = []
        puzzle = puzzle[1:-1]
        puzzle = puzzle.split('\n')
        for i in range(len(puzzle)):
            puzzle[i] = puzzle[i].strip()
        for row in puzzle:
            list_row = []
            row = row[1:-1]
            row = row.strip('[').strip(']').strip()
            for i in range(len(row)):
                if row[i] != ' ':
                    cell = int(row[i])
                    list_row.append(cell)
            transformed_puzzle.append(list_row)
        return transformed_puzzle
    
    @staticmethod
    def transform_current_state_to_dict(current_state):
        print(current_state)
        print(type(current_state))
        transformed_state = []
        for row in current_state:
            new_row = []
            for value in row:
                cell = {'value': value, 'clue': value != 0}
                new_row.append(cell)
            transformed_state.append(new_row)
        return transformed_state
    
    @staticmethod
    def delete_game(gameid, userid):
        game = Sudoku.objects.get(id=gameid, player=userid)
        if game:
            game.delete()
            return True
        else:
            return False
        
    @staticmethod
    def update_time(gameid, time):
        game = Sudoku.objects.get(id=gameid)
        game.time = time
        game.save()
        return True
    
    @staticmethod
    def save_game(gameid, current_state, time):
        game = Sudoku.objects.get(id=gameid)
        game.current_state = current_state
        game.time = time
        game.save()
        return True
    

    ##serializers.py

    from rest_framework import serializers
from .models import Sudoku
import json

class SudokuSerializer(serializers.ModelSerializer):
    transformed_state = serializers.SerializerMethodField()
    transformed_solution = serializers.SerializerMethodField()
    class Meta:
        model = Sudoku
        fields = [
            'id', 'player', 'puzzle', 'current_state', 'difficulty', 'time',
            'is_finished', 'win', 'created_at', 'updated_at', 'transformed_state', 'transformed_solution', 'solution'
        ]
        depth = 1  # This is optional, use if you want to include nested relations
    
    def get_transformed_state(self, obj):
        try:
            return json.loads(obj.current_state)
        except json.JSONDecodeError:
            print('Error decoding JSON')
            return None
        
    def get_transformed_solution(self, obj):
        try:
            return json.loads(obj.solution)
        except json.JSONDecodeError:
            print('Error decoding JSON')
            return None

##sudoku_logic.py

import random
import numpy as np

def is_valid(board, row, col, num):
    for x in range(9):
        if board[row][x] == num or board[x][col] == num:
            return False
    startRow = row - row % 3
    startCol = col - col % 3
    for i in range(3):
        for j in range(3):
            if board[i + startRow][j + startCol] == num:
                return False
    return True

def find_empty_location(board, l):
    for row in range(9):
        for col in range(9):
            if board[row][col] == 0:
                l[0] = row
                l[1] = col
                return True
    return False

def solve_sudoku(board):
    l = [0, 0]
    if not find_empty_location(board, l):
        return True
    row, col = l
    nums = list(range(1,10))
    random.shuffle(nums)
    for num in nums:
        if is_valid(board, row, col, num):
            board[row][col] = num
            if solve_sudoku(board):
                return True
            board[row][col] = 0
    return False


def generate_sudoku_solution():
    board = np.zeros((9, 9), dtype=int)
    nums = list(range(1,10))
    random.shuffle(nums)
    board[0] = nums
    if solve_sudoku(board):
        return board
    return None


def generate_puzzle(difficulty):
    solution_board = generate_sudoku_solution()
    clues = int()   
    if difficulty == 'test':
        clues = 80
    if difficulty == 'easy':
        clues = 40  
    if difficulty == 'medium':
        clues = 30
    if difficulty == 'hard':
        clues = 20
    if solution_board is not None:
        board = remove_numbers_to_create_puzzle(solution_board.tolist(), clues)
        return board, solution_board

def remove_numbers_to_create_puzzle(board, clues):
    puzzle_board = np.copy(board)
    count = 81 - clues
    while count > 0:
        i, j = random.randint(0, 8), random.randint(0, 8)
        if puzzle_board[i][j] != 0:
            puzzle_board[i][j] = 0
            count -= 1
    return puzzle_board

    
    
def check_sudoku_board(board):
    # Check each row
    for row in board:
        if not is_valid_group(row):
            return False

    # Check each column
    for col in range(9):
        if not is_valid_group([board[row][col] for row in range(9)]):
            return False

    # Check each 3x3 square
    for box_row in range(0, 9, 3):
        for box_col in range(0, 9, 3):
            if not is_valid_box(board, box_row, box_col):
                return False

    # If all checks pass
    return True

def is_valid_group(group):
    """Check if a group (row/column) contains unique numbers from 1 to 9."""
    return sorted(group) == list(range(1, 10))

def is_valid_box(board, start_row, start_col):
    """Check if a 3x3 box contains unique numbers from 1 to 9."""
    numbers = []
    for row in range(3):
        for col in range(3):
            numbers.append(board[start_row + row][start_col + col])
    return is_valid_group(numbers)

def check_sudoku_solution(board):
    errors = {'rows': [], 'columns': [], 'boxes': []}
    print(board)

    # Convert board to only numbers for validation
    num_board = [[cell['value'] for cell in row] for row in board]

    # Check each row
    for i, row in enumerate(num_board):
        if not is_valid_group(row):
            errors['rows'].append(i)

    # Check each column
    for j in range(9):
        column = [num_board[i][j] for i in range(9)]
        if not is_valid_group(column):
            errors['columns'].append(j)

    # Check each 3x3 square
    for box_row in range(0, 9, 3):
        for box_col in range(0, 9, 3):
            if not is_valid_box(num_board, box_row, box_col):
                errors['boxes'].append((box_row // 3, box_col // 3))

    is_correct = not (errors['rows'] or errors['columns'] or errors['boxes'])
    print(is_correct, errors)
    return is_correct, errors


##urls.py

from django.urls import path
from . import views

urlpatterns = [
    path('play', views.create_sudoku_game, name='sudoku'),
    path('updateTime', views.GenerateSudokuView.as_view(), name='sudokuTimer'),
    path('checkSolution', views.check_sudoku_solution, name='sudokuSolution'),
    path('giveUp', views.give_up, name='sudokuGiveUp'),
    path('savedGames', views.get_user_games, name='savedGames'),
    path('deleteGame', views.delete_game, name='deleteGame'),
    path('saveGame', views.save_game, name='saveGame'),
]



##views.py

from django.shortcuts import render
from django.http import JsonResponse
from rest_framework.response import Response
from rest_framework.generics import RetrieveUpdateAPIView
from .models import Sudoku
from .serializers import SudokuSerializer
from django.contrib.auth.models import User
import json
from . import sudoku_logic

# Create your views here.
class GenerateSudokuView(RetrieveUpdateAPIView):
    def get(self, request, format=None):
        try:
            userid = request.GET['userid']
            user = User.objects.get(id=userid)
        except:
            user = None
        difficulty = request.GET['difficulty']
        puzzle = sudoku_logic.generate_puzzle(difficulty)
        puzzle_list = puzzle.tolist()
        if puzzle is not None:
            Sudoku.objects.create(
                difficulty=difficulty, 
                puzzle=puzzle_list, 
                current_state=puzzle, 
                player=user)
            game = Sudoku.objects.filter(puzzle=puzzle_list, player=user).latest('created_at')
            
            return Response(
                {'status': 'success', 
                 'gameid' : game.id, 
                 'puzzle': puzzle_list,
                 'difficulty': game.difficulty,
                 'time': game.time})
        else:
            return Response({'status': 'failure'})
        
    def put(self, request, format=None):
        data = json.loads(request.body)
        sudoku_id = data['sudoku_id']
        time = data['time']
        sudoku = Sudoku.objects.get(id=sudoku_id)
        sudoku.time = time
        sudoku.save()
        return Response({'status': 'success'})


def create_sudoku_game(request):
    data=request.GET
    print(data)
    userid = data['userid']
    difficulty = data['difficulty']
    pack = {'userid': userid, 'difficulty': difficulty}
    game = Sudoku.create(pack)
    if game:
        serializer = SudokuSerializer(game)
        return JsonResponse(serializer.data, safe=False)
    else:
        return JsonResponse({'error': 'Failed to create game'}, status=404)

    
def get_user_games(request):
    userid = request.GET['userid']
    games = Sudoku.get_user_games(userid)
    if games:
        serializer = SudokuSerializer(games, many=True)
        return JsonResponse(serializer.data, safe=False)  # Convert to JSON and return
    else:
        return JsonResponse({'error': 'User not found or no games available'}, status=404)

def delete_game(request):
    data= json.loads(request.body)
    gameid = data['gameid']
    userid = data['userid']
    
    deleted = Sudoku.delete_game(gameid, userid)
    if deleted:
        return JsonResponse({'status': 'success'})
    else:
        return JsonResponse({'status': 'failure'}, status=404)
    
def save_game(request):
    data = json.loads(request.body)
    gameid = data['gameid']
    current_state = data['current_state']
    time = data['time']
    saved = Sudoku.save_game(gameid, current_state, time)
    if saved:
        return JsonResponse({'status': 'success'})
    else:
        return JsonResponse({'status': 'failure'}, status=404)
    
def check_sudoku_solution(request):
    data = json.loads(request.body)
    board = data['board']
    result = sudoku_logic.check_sudoku_solution(board)
    is_correct = result[0]
    errors = result[1]
    if result:
        return JsonResponse({'status': 'success', 'is_correct': is_correct, 'errors': errors})
    else:
        return JsonResponse({'status': 'failure'}, status=404)

def give_up(request):
    data = json.loads(request.body)
    gameid = data['gameid']
    game = Sudoku.objects.get(id=gameid)
    game.is_finished = True
    game.win = False
    game.save()
    return JsonResponse({'status': 'success'})

##FRONTEND

##BoardComponent.jsx

import React, { useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import SudokuCell from './CellComponent';
import './Sudoku.css';

const SudokuBoard = ({current_state, paused, onBoardChange, showSolution, errors}) => {

    const [board, setBoard] = useState(Array(9).fill().map(() => Array(9).fill({ value: 0, clue: false })));

   
    
    const initializeBoard = (current_state) => {
        if(Array.isArray(current_state)){
        const newBoard = current_state.map((row, rowIndex) => 
            row.map((cell => ({
                value: cell.value,
                clue: cell.clue ,
                error: false
            }))
        ));
        setBoard(newBoard);
    }
    };
    const handleInputChange = (newValue, rowIndex, colIndex) => {
        if (paused) return;
        const newBoard = [...board];
        const numericValue = isNaN(parseInt(newValue)) ? 0 : parseInt(newValue);
        newBoard[rowIndex][colIndex] = { ...newBoard[rowIndex][colIndex], value: numericValue };
        setBoard(newBoard);
        if (onBoardChange) {
            onBoardChange(newBoard);
        }
    };
    const noop = () => {};

    
    useEffect(() => { 
        initializeBoard(current_state);
    }, [current_state]); 

    const errorsToCellPositions = (errors) => {
        var errorCells = new Set();

        // Add cells that are at the intersection of erroneous rows and columns.
        errors.rows.forEach(rowIndex => {
            errors.columns.forEach(colIndex => {
                errorCells.add(`${rowIndex}-${colIndex}`);
            });
        });
        var errorInstance = errorCells;
    return errorInstance;
    };

    
    
    
    useEffect(() => {
        if (!errors || (!errors.rows.length && !errors.columns.length && !errors.boxes.length)) {
            console.log('No errors to process.');
            return; // Exit if there are no actual errors.
        }
        console.log('Updating board for errors:', errors);
        console.log('errors!!!!!:', errors);
        // This code should run only if `errors` change.
        var errorCells = errorsToCellPositions(errors);
        console.log('errorCells:', errorCells)
        const newBoard = board.map((row, rowIndex) =>
            row.map((cell, colIndex) => {
                const isError = errorCells.has(`${rowIndex}-${colIndex}`);
                return { ...cell, error: isError }; 
            })
        );
        errorCells = new Set();
        setBoard(newBoard);
    }, [errors]);

    return (
        <>
        <br />
        {!paused &&
            <>
            <div id="sudokuBoard" className="sudoku-board">
                {board.map((row, rowIndex) => (
                    <div key={rowIndex} className="sudoku-row">
                        {row.map((cell, colIndex) => (
                            <SudokuCell
                                key={`${rowIndex}-${colIndex}`}
                                cell={cell}
                                rowIndex={rowIndex}
                                colIndex={colIndex}
                                onInputChange={handleInputChange}
                                isError={cell.error}
                                
                            />
                        ))}
                    </div>
                ))}
            </div>
        </>}
        {paused && 
            <>
            <pausedBoard />
            </>
        }
    </>
    );
}


SudokuBoard.propTypes = {
    current_state: PropTypes.array,
    solution: PropTypes.array,
    paused: PropTypes.bool,
    onBoardChange: PropTypes.func,
    showSolution: PropTypes.bool,
    errors: PropTypes.shape({ // Use PropTypes.shape for better structuring
        rows: PropTypes.arrayOf(PropTypes.number),
        columns: PropTypes.arrayOf(PropTypes.number),
        boxes: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.number))
    }),
};

export default SudokuBoard;

##CellComponent.jsx

import React from 'react';
import PropTypes from 'prop-types';
import './Sudoku.css';
import { useState, useEffect } from 'react';

const SudokuCell = ({ cell, rowIndex, colIndex, onInputChange, isError }) => {
    const [showError, setShowError] = useState(false);
    useEffect(() => {   
        setShowError(isError);
        if (isError) {
            const timer = setTimeout(() => setShowError(false), 2000); // 2 seconds
            return () => clearTimeout(timer);
        }
    }, [isError]);

    const handleChange = (event) => {
        const newValue = event.target.value.replace(/[^1-9]/g, '');
        if (newValue.length <= 1) {
            onInputChange(newValue, rowIndex, colIndex);
            setShowError(false);
        }
    };
    


    return (
        <div className={`sudoku-cell ${colIndex === 2 || colIndex === 5 ? 'bold-border-right' : ''} ${rowIndex === 2 || rowIndex === 5 ? 'bold-border-bottom' : ''}`}>
            <input
                type="text"
                value={cell.value || ''}
                onChange={handleChange}
                className={`sudoku-input ${cell.clue ? 'concrete' : ''} ${showError ? 'error-cell' : ''}`}
                disabled={cell.clue}
                
                
            />
        </div>
    );
};

SudokuCell.propTypes = {
    cell: PropTypes.object.isRequired,
    rowIndex: PropTypes.number.isRequired,
    colIndex: PropTypes.number.isRequired,
    onInputChange: PropTypes.func.isRequired,
    isError: PropTypes.bool,
};

export default SudokuCell;

##DifficultySelectorComponent.jsx

import React from 'react';
import { Dropdown, Header} from 'semantic-ui-react';
import PropTypes from 'prop-types';
import IsButton from '../../components/IsButton';
import { useState, useEffect } from 'react';
import { useNavigate} from 'react-router-dom';
import axios from 'axios';

const DifficultySelector = ({handleClose}) => {
    DifficultySelector.propTypes = {
        handleClose: PropTypes.func,
    };

    const [difficulty, setDifficulty] = useState('easy');
    const navigate = useNavigate();

    useEffect (() => {
        console.log('Difficulty:', difficulty);
    }, [difficulty]);

    const startGame = () => {
        console.log('Start game with difficulty:', difficulty);
        console.log('user:', localStorage.getItem('userId'));

        axios.get(`${process.env.REACT_APP_API_URL}/api/sudoku/play`, {
            params: {
                difficulty: difficulty,
                userid: localStorage.getItem('userId')
            }
        }).then((response) => {
            console.log('Game started:', response.data);
            navigate('/apps/sudoku/game', 
            {state: {current_state: response.data.transformed_state, 
                solution: response.data.transformed_solution,
                    gameid: response.data.id,
                    time: response.data.time, 
                    difficulty: response.data.difficulty, 
                    userid: response.data.player.id}});
     
            handleClose();
        }).catch((error) => {
            console.error('Failed to start game:', error);
        });
    }
    const difficultyOptions = [
        { key: 'easy', text: 'Easy', value: 'easy' },
        { key: 'medium', text: 'Medium', value: 'medium' },
        { key: 'hard', text: 'Hard', value: 'hard' },
    ];
    

    return (
        <>
        <Header as='h3' content='Select Difficulty' />
        <div style={{display:'flex', justifyContent:'space-between'}}>
        <Dropdown
            placeholder='Select Difficulty'
            selection
            options={difficultyOptions}
            defaultValue={difficulty}
            onChange={(e, data) => setDifficulty(data.value)}
        />
        <IsButton
            label='Start Game'
            onClick={startGame}
            color='green'
        ></IsButton>
        </div>
        </> 
    );
}

export default DifficultySelector;

##PausedBoardComponent.jsx

import React from 'react';
import SudokuCell from './CellComponent';

const PausedBoard = () => {
    const noop = () => {}; // Presuming this is intentionally a no-operation function for placeholder.
    const gridSize = 9; // for a standard Sudoku board
    let board = [];
    for (let row = 0; row < gridSize; row++) {
        let currentRow = [];
        for (let col = 0; col < gridSize; col++) {
            // Insert 'SUDOKU' letters into the middle row
            // Ensure you handle out-of-bounds correctly for '数独-SUDOKU' string
            let cellContent = row === 4 ? ('数独-SUDOKU'[col] || '') : Math.ceil(Math.random() * 9);
            currentRow.push(
                <SudokuCell
                    key={`${row}-${col}`}
                    cell={{ value: cellContent, clue: row !== 4 }}
                    rowIndex={row}
                    colIndex={col}
                    onInputChange={noop}
                />
            );
        }
        board.push(<div key={row} style={{ display: 'flex' }}>{currentRow}</div>); // Added key to each row for React list elements
    }
    return (
        <div id="sudokuBoard" className="sudoku-board">
            {board}
        </div>
    );
};

export default PausedBoard;


##SavedGamesComponent.jsx

import React from 'react';
import { Dropdown, Header} from 'semantic-ui-react';
import PropTypes from 'prop-types';
import IsButton from '../../components/IsButton';
import axios from 'axios';
import { useState, useEffect } from 'react';
import { useNavigate} from 'react-router-dom';


const UserSavedGames = () => {
    
    const [games, setGames] = useState([]);
    const [selectedGame, setSelectedGame] = useState({});//[0].current_state);
    const navigate = useNavigate();
    var user = localStorage.getItem('userId');
    var token = localStorage.getItem('token');

    const gameOptions = games.map(game => {
        return { key: game.id, text: (game.difficulty + game.created_at.slice(5,10)), value: game.id }
    });

    const handleGameSelect = (gameid) => {
        console.log('Game selected:', gameid);
        setSelectedGame(games.filter(game => game.id === gameid)[0]);
    }

    const onDeleteGame = () => {
        console.log('Delete game:', selectedGame.id);
        axios.delete(`${process.env.REACT_APP_API_URL}/api/sudoku/deleteGame`, {
            data: {
                gameid: selectedGame.id,
                userid: user
            },
            withCredentials: true,
            headers: { 
                'Content-Type': 'application/json',
                'X-CSRFToken': document.cookie.split('=')[1]
            }
        }).then((response) => {
            console.log('Game deleted:', response.data);
            setGames(games.filter(game => game.id !== selectedGame.id));
        }).catch((error) => {
            console.error('Failed to delete game:', error);
        });
    }

    const onLoadGame = () => {
        console.log('Load game:', selectedGame.id);
        console.log('Current State:', selectedGame.transformed_state)
        navigate('/apps/sudoku/game', 
        {state: {current_state: selectedGame.transformed_state, 
            solution: selectedGame.transformed_solution,
                gameid: selectedGame.id,
                time: selectedGame.time, 
                difficulty: selectedGame.difficulty, 
                userid: selectedGame.player.id}});
    }



    useEffect(() => {
        console.log('User:', user)
        axios.get(`${process.env.REACT_APP_API_URL}/api/sudoku/savedGames`, {
            withCredentials: true,
            headers: { 
                'Content-Type': 'application/json',
            },
            params: {
                userid: user
            }
        }).then((response) => {
            console.log('Saved Games:', response.data);
            setGames(response.data);
        }).catch((error) => {
            console.error('Failed to get saved games:', error);
        });
    }
    , [user]);
    return (
        <>
        <Header as='h3' content='Select Game' />
        <Dropdown
            placeholder='Select Game'
            selection
            options={gameOptions}
            onChange={(e, data) => handleGameSelect(data.value)}
        />
        <IsButton
            label='Continue Game'
            onClick={(onLoadGame)} 

        ></IsButton>
        <IsButton
            label='Delete Game'
            onClick={onDeleteGame}
            color='red'
        ></IsButton>
        </> 
    );
}

UserSavedGames.propTypes = {
    games: PropTypes.array,
    
};


export default UserSavedGames;

##SolutionBoardComponent.jsx

import React, { useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import SudokuCell from './CellComponent';
import './Sudoku.css';

const SolutionBoard = ({ puzzle, solution }) => {
    const [board, setBoard] = useState(Array(9).fill().map(() => Array(9).fill({ value: 0, clue: false })));

    const initializeBoard = () => {
        if (Array.isArray(puzzle) && Array.isArray(solution)) {
            const newBoard = puzzle.map((row, rowIndex) =>
                row.map((cell, colIndex) => ({
                    value: solution[rowIndex][colIndex], // Value from the solution
                    clue: !!cell.clue, // Using !! to ensure it's a boolean
                    error: cell.value !== 0 && cell.value !== solution[rowIndex][colIndex] // Check if there's a mismatch
                }))
            );
            setBoard(newBoard);
        }
    };

    useEffect(() => {
        initializeBoard();
    }, [puzzle, solution]);

    return (
        <div id="sudokuBoard" className="sudoku-board">
            {board.map((row, rowIndex) => (
                <div key={rowIndex} className="sudoku-row">
                    {row.map((cell, colIndex) => (
                        <SudokuCell
                            key={`${rowIndex}-${colIndex}`}
                            cell={cell}
                            rowIndex={rowIndex}
                            colIndex={colIndex}
                            onInputChange={() => {}} // No-op function
                            isError={cell.error}
                        />
                    ))}
                </div>
            ))}
        </div>
    );
};

SolutionBoard.propTypes = {
    puzzle: PropTypes.arrayOf(PropTypes.array).isRequired,
    solution: PropTypes.arrayOf(PropTypes.array).isRequired
};

export default SolutionBoard;


##SudokuGamePage.jsx

import React from "react";
import { useLocation } from "react-router-dom";
import {
  Segment,
  Header,
  Container,
  Grid,
  GridColumn,
} from "semantic-ui-react";
import { useState, useEffect, useCallback } from "react";
import { useNavigate } from "react-router-dom";
import axios from "axios";
import CSRFToken from "../../utils/CsrfToken";
import IsButton from "../../components/IsButton";
import PausedSudokuBoard from "./PausedBoardComponent";
import SudokuBoard from "./BoardComponent";
import SolutionBoard from "./SolutionBoardComponent";
import Timer from "../../components/Timer";
import Cookies from "js-cookie";

const SudokuGame = () => {
  const location = useLocation();
  const puzzle = location.state ? location.state.current_state : [];
  const difficulty = location.state ? location.state.difficulty : "";
  const gameid = location.state ? location.state.gameid : "";
  const time = location.state ? location.state.time : 0;
  const user = location.state ? location.state.userid : "";
  const solution = location.state ? location.state.solution : [];
  const [showSolution, setShowSolution] = useState(false);
  const [isTimerActive, setIsTimerActive] = useState(true);
  const [timerTime, setTimerTime] = useState(time);
  const [currentBoard, setCurrentBoard] = useState(puzzle); // Initialize with the initial puzzle.
  const [stop, setStop] = useState(false);
  const navigate = useNavigate();
  var token = Cookies.get("csrftoken");

  const handleBoardChange = (newBoard) => {
    setCurrentBoard(newBoard);
  };

  const handleGiveUp = () => {
    setShowSolution(true);
    console.log(solution);
    console.log(puzzle)
    setStop(true);
    setIsTimerActive(false);
    axios
      .put(
        `${process.env.REACT_APP_API_URL}/api/sudoku/giveUp`,
        {
          gameid: gameid,
        },
        {
          withCredentials: true,
          headers: {
            "X-CSRFToken": token,
            "Content-Type": "application/json",
          },
        }
      )
      .then((response) => {
        console.log("Game given up:", response.data);
        console.log(response);
      })
      .catch((error) => {
        console.error("Failed to give up game:", error);
      });
  };

  useEffect(() => {
    if (isTimerActive) {
      const timerId = setInterval(() => {
        setTimerTime((timerTime) => timerTime + 1);
      }, 1000);
      return () => clearInterval(timerId);
    }
  }, [isTimerActive]);

  const saveTime = () => {
    // console.log('Save time:', timerTime);
    axios
      .put(
        `${process.env.REACT_APP_API_URL}/api/sudoku/updateTime`,
        {
          sudoku_id: gameid,
          time: timerTime,
        },
        {
          withCredentials: true,
          headers: {
            "X-CSRFToken": token,
            "Content-Type": "application/json",
          },
        }
      )
      .then((response) => {
        // console.log('Time saved:', response.data);
      })
      .catch((error) => {
        console.error("Failed to save time:", error);
      });
  };

  const saveGame = () => {
    console.log("Save game:", gameid);
    axios
      .put(
        `${process.env.REACT_APP_API_URL}/api/sudoku/saveGame`,
        {
          gameid: gameid,
          userid: user,
          current_state: currentBoard,
          time: timerTime,
        },
        {
          withCredentials: true,
          headers: {
            "X-CSRFToken": token,
            "Content-Type": "application/json",
          },
        }
      )
      .then((response) => {
        console.log("Game saved:", response.data);
      })
      .catch((error) => {
        console.error("Failed to save game:", error);
      });
  };

  const [errors, setErrors] = useState({ rows: [], columns: [], boxes: [] });
  useEffect(() => {
    if (
      errors &&
      (errors.rows.length || errors.columns.length || errors.boxes.length)
    ) {
      const errorTimeout = setTimeout(() => {
        // Clear the errors from state here if necessary
        setErrors({ rows: [], columns: [], boxes: [] });
      }, 1000); // Match this duration to your CSS animation

      return () => clearTimeout(errorTimeout);
    }
  }, [errors]);

  const checkSolution = () => {
    axios
      .post(
        `${process.env.REACT_APP_API_URL}/api/sudoku/checkSolution`,
        {
          board: currentBoard, // Adjust with the correct format
        },
        {
          headers: { "Content-Type": "application/json", "X-CSRFToken": token },
          withCredentials: true,
        }
      )
      .then((response) => {
        const { status, isCorrect, errors } = response.data;
        console.log("Response:", response.data);
        console.log("Status:", status);
        console.log("Correct:", isCorrect ? "Yes" : "No");
        console.log("Errors:", errors);
        if (status === "success") {
          console.log("Solution checked:", isCorrect);

          if (isCorrect) {
            alert("Congratulations! Correct solution.");
          } else {
            alert("Incorrect solution.");
            setErrors(errors);
            console.log("Errors:", errors);
          }
          // handle game win logic here
        } else {
          console.log("Issue sending");
        }
      })
      .catch((error) => {
        console.error("Error checking solution:", error);
      });
  };

  const backToMenu = () => {
    console.log("Back to menu");
    navigate("/apps/sudoku");
  };

  const noop = () => {};

  const toggleTimer = () => {
    setIsTimerActive(!isTimerActive);
  };

  return (
    <>
      <Container
        style={{
          display: "flex",
          justifyContent: "space-evenly",
          alignItems: "center",
        }}
      >
        <Segment style={{ display: "flex", flexDirection: "column" }}>
          {!showSolution && (
            <>
              <Header as="h3">Game Controls</Header>
              <IsButton
                label="Check"
                color="green"
                style={{ marginBottom: "1em" }}
                onClick={checkSolution}
              ></IsButton>
              <IsButton
                label={isTimerActive ? "Pause" : "Resume"}
                color="grey"
                style={{ marginBottom: "1em" }}
                onClick={toggleTimer}
              ></IsButton>
              <IsButton
                label="Save Game"
                color="blue"
                style={{ marginBottom: "1em" }}
                onClick={saveGame}
              ></IsButton>
              <IsButton
                label="Give Up"
                color="red"
                onClick={handleGiveUp}
              ></IsButton>
            </>
          )}
          {showSolution && (
            <>
              <Header as="h3">Back to Menu</Header>
              <IsButton
                label="Back"
                color="blue"
                onClick={backToMenu}
              ></IsButton>
            </>
          )}
        </Segment>
        <Segment>
          {!showSolution && (
            <>
              <Grid
                columns={3}
                style={{
                  display: "flex",
                  justifyContent: "space-evenly",
                  alignItems: "center",
                  textAlign: "center",
                }}
              >
                <GridColumn align="left">
                  <Header as="h3" style={{ textTransform: "capitalize" }}>
                    {difficulty} Sudoku
                  </Header>
                </GridColumn>
                <GridColumn></GridColumn>
                <GridColumn align="right">
                  <Timer
                    isActive={isTimerActive}
                    onStop={stop}
                    onTimeChange={saveTime}
                    initialTime={timerTime}
                  />
                </GridColumn>
              </Grid>
              {isTimerActive && (
                <SudokuBoard
                  current_state={puzzle}
                  onBoardChange={handleBoardChange}
                  errors={errors}
                />
              )}
              {!isTimerActive && (
                <>
                  <br />
                  <PausedSudokuBoard />
                </>
              )}
            </>
          )}
          <br />
          {showSolution && (
            <>
              <Grid
                columns={3}
                style={{
                  display: "flex",
                  justifyContent: "space-evenly",
                  alignItems: "center",
                  textAlign: "center",
                }}
              >
                <GridColumn align="left">
                  <Header as="h3" style={{ textTransform: "capitalize" }}>
                    Game Over - Lost
                  </Header>
                </GridColumn>
                <GridColumn></GridColumn>
                <GridColumn align="right">
                  <Timer
                    isActive={isTimerActive}
                    onStop={stop}
                    onTimeChange={saveTime}
                    initialTime={timerTime}
                  />
                </GridColumn>
              </Grid>
              <br />
                <SolutionBoard puzzle={puzzle} solution={solution} />
            </>
          )}
        </Segment>
      </Container>
    </>
  );
};

export default SudokuGame;


##SudokuPage.jsx

import React from 'react';
import { Container, Header, Segment, Card, Grid, Divider } from 'semantic-ui-react';
import IsPortal from '../../components/IsPortal';
import DifficultySelector from './DifficultySelectorComponent';
import UserSavedGames from './SavedGamesComponent';


const SudokuPage = () => {
    return (
        <Container>
            <br />
            <Header as='h1'>Sudoku</Header>
            <Segment style={{ padding: '2em 2em', margin: '2em'}}>
                <Grid columns={2} relaxed='very'>
                    <Grid.Column>
                        <Card>
                            <Card.Content>
                                <Card.Header>Play</Card.Header>
                                <Card.Description>
                                    Play a game of Sudoku
                                </Card.Description>
                                <IsPortal
                                    label='Go!'
                                    content={<p>Play Sudoku</p>}
                                >
                                    <DifficultySelector />
                                </IsPortal>     
                            </Card.Content>
                        </Card>
                    </Grid.Column>
                    <Grid.Column>
                        <Card>
                            <Card.Content>
                                <Card.Header>Continue</Card.Header>
                                <Card.Description>
                                    Continue one of your saved games
                                </Card.Description>
                                <IsPortal
                                    label='Continue'
                                    >
                                    <UserSavedGames />

                                </IsPortal>
                            </Card.Content>
                        </Card>
                    </Grid.Column>
                </Grid>
                <Divider vertical>Or</Divider>
            </Segment>
        </Container>
    );
};

export default SudokuPage;

##sudoku.css


.starterButtons{
    background-color: var(--color_quaternary);
    transition: .5s;
}
#startButton:hover {
    background-color: #4b9a46;
    color: #fff;
}



.sudoku-board {
    display: grid;
    grid-template-rows: repeat(9, 1fr); /* Creates 9 rows */
    /* grid-gap: 2px; Adjust based on your design */
    max-width: 40rem;
    margin: auto;
    background-color: #3333333a;
    padding: 5px;
    border-radius: 10px;
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
}

.sudoku-row {
    display: flex; /* This will layout the child cells in a row */
    justify-content: center;
}

.sudoku-cell {
    width: 4rem; /* Or adjust based on your design */
    height: 4rem;
    background-color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    color: #333;
    border-left: 2px solid #666;
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
}

.sudoku-input {
    width: 100%;
    height: 100%;
    border: none;
    text-align: center;
    font-size: 20px;
    background-color: transparent;
    color: #333;
    font-family: 'Arial', sans-serif;
}

.bold-border-right {
    border-right: 4px solid #666; 
}
.bold-border-bottom {
    border-bottom: 4px solid #666;
}

.locked {
    font-weight: bold; 
    cursor:not-allowed; 
}
.concrete {
    width: 100%;
    height: 100%;
    border: none;
    text-align: center;
    font-size: 20px;
    background-color: rgba(79, 66, 66, 0.929); 
    color: rgb(255, 255, 255) !important; 
    font-family: 'Arial', sans-serif; 
}
@keyframes flashError {
    0% { color: initial;}
    50% { color : red; background-color: black;}
    100% { color: initial;}
}

.error-cell {
    animation: flashError 1s ease-out infinite;
}

